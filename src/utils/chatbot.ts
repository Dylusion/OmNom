import {
  ChannelType,
  PermissionFlagsBits,
  type Message,
  type TextBasedChannel,
} from "discord.js";
import { replaceAsync } from "./string.js";
import emojiRegex from "emoji-regex";
import { EmojiRegex } from "@sapphire/discord.js-utilities";
import env from "../env/bot.js";

export async function parseUserInput(message: Message) {
  let content = message.content;

  // Replace all emojis with their :names:
  content = content.replaceAll(
    /<(?:(?<animated>a)?:(?<name>\w{2,32}):)?(?<id>\d{17,21})>/g,
    (...args) => `:${args[2]}:`
  );

  // Replace all mentions with their @names
  content = await replaceAsync(
    content,
    /<@!?(?<id>\d{17,20})>/g,
    async (...args) => {
      const id = args[1] as string;

      const user = await message.client.users.fetch(id);

      if (!user) return "@User";

      return `@${user.username}`;
    }
  );

  // Add all attachments to the end
  content += message.attachments.map((attachment) => attachment.url).join("\n");

  // Make it single-line if required
  content = content.replaceAll(env.CHATBOT_SINGLE_LINE ? "\n" : " ", " ");

  return content;
}

export async function createPrompt(
  name: string,
  persona?: string,
  greeting?: string,
  messages?: Message[]
) {
  let prompt = "";

  // If we have a persona, add it to the prompt
  if (persona !== "")
    // ${name}'s Persona: ${persona}
    prompt += `${name}'s Persona: ${
      persona ??
      // Default value:
      `${name} is a highly intelligent language model trained to comply with user requests.`
    }\n`;

  // The docs say to add this as a delimiter
  prompt += "<START>\n";

  // If we have a greeting, add it to the prompt
  // ${name}: ${greeting}
  if (greeting) prompt += `${name}: ${greeting}\n`;

  // If we have message history, add the messages to the prompt
  if (messages)
    prompt += (
      await Promise.all(
        messages.map(
          async (message) =>
            // ${username}: ${message}
            `${message.author.username}: ${await parseUserInput(message)}`
        )
      )
    ).join("\n");

  // Add the chat bot's name to the prompt
  prompt += `\n${name}:`;
  return prompt;
}

// TODO: Implement @ lookups
export function parseBotInput(
  name: string,
  message: string
): [string, ...string[]] {
  // Get all lines generated by the bot
  const lines = message.trim().split("\n");

  // The first line will always the bot's response
  const botLine = lines.splice(0, 1)[0] as string;

  // The bot likes to impersonate the user, so we need to check for that
  let foundImpersonation = false;
  const botLines = lines
    .filter((line) => {
      if (foundImpersonation) return false;
      if (line.startsWith(`${name}: `)) return true;
      foundImpersonation = true;
      return false;
    })
    .map((line) => line.replace(`${name}: `, "").trim());

  return [botLine, ...botLines];
}

export const forgetReactionIsEmoji =
  emojiRegex().test(env.CHATBOT_FORGET_REACTION) ||
  EmojiRegex.test(env.CHATBOT_FORGET_REACTION);

export function hasReactionPermissions(channel: TextBasedChannel) {
  return (
    channel.type == ChannelType.DM ||
    channel
      .permissionsFor(channel.client.id || "")
      ?.has(
        forgetReactionIsEmoji
          ? PermissionFlagsBits.AddReactions
          : PermissionFlagsBits.SendMessages
      )
  );
}
